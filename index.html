<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>RPS Game of Life</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            margin: 0;
        }

        #ui {
            width: 200px;
            padding: 10px;
            background: #f0f0f0;
            border-right: 1px solid #ccc;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(72, 12px);
            grid-template-rows: repeat(72, 12px);
            gap: 1px;
            margin: 10px;
            transform: rotate(45deg) scale(1.3);
            transform-origin: center;
        }

        .cell {
            width: 12px;
            height: 12px;
            background: white;
            border: 1px solid #eee;
            cursor: pointer;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .rock {
            background: red;
        }

        .paper {
            background: green;
        }

        .scissors {
            background: blue;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3>Controls</h3>
        <button id="toggleBtn">Stop</button>
        <button id="resetBtn">Clear</button>
        <button id="randomizeBtn">Randomize</button>
        <br><br>
        <label for="speed">Speed (ms):</label>
        <input type="number" id="speed" value="100" min="100" step="100">
        <br><br>
        <label for="cpuInterval">CPU Glider Interval (ms):</label>
        <input type="number" id="cpuInterval" value="1000" min="1000" step="500">
        <br><br>
        <div>
            <strong>Color:</strong><br>
            <label><input type="radio" name="color" value="rock" checked> Rock</label><br>
            <label><input type="radio" name="color" value="paper"> Paper</label><br>
            <label><input type="radio" name="color" value="scissors"> Scissors</label><br>
            <label><input type="radio" name="color" value="random"> Random</label><br>
            <label><input type="radio" name="color" value="0"> Eraser</label>
        </div>
        <br>
        <div>
            <strong>Tool:</strong><br>
            <label><input type="radio" name="tool" value="1x1"> 1x1</label><br>
            <label><input type="radio" name="tool" value="2x2"> 2x2 Block</label><br>
            <label><input type="radio" name="tool" value="1x3"> 1x3 Blinker</label><br>
            <label><input type="radio" name="tool" value="block"> Block</label><br>
            <label><input type="radio" name="tool" value="cross"> Cross</label><br>
            <label><input type="radio" name="tool" value="line"> Diagonal Line</label><br>
            <label><input type="radio" name="tool" value="glider-n"> Glider N</label><br>
            <label><input type="radio" name="tool" value="glider-e"> Glider E</label><br>
            <label><input type="radio" name="tool" value="glider-s"> Glider S</label><br>
            <label><input type="radio" name="tool" value="glider-w"> Glider W</label><br>
            <label><input type="radio" name="tool" value="glider-random" checked> Glider Random</label>
        </div>
    </div>

    <div id="grid"></div>

    <script>
        const width = 72, height = 72;
        const halfWidth = width / 2, halfHeight = height / 2;
        let grid = [];
        let running = false;
        let interval;
        let cpuIntervalID;

        const gridContainer = document.getElementById('grid');

        function createGrid() {
            grid = Array.from({ length: height }, () => Array(width).fill(0));
            gridContainer.innerHTML = '';
            for (let y = 0; y < height; y++) {
                const dy = Math.abs(y - halfHeight);
                for (let x = 0; x < width; x++) {
                    const cell = document.createElement('div');
                    const vissible = (dy + Math.abs(x - halfWidth)) <= halfWidth;
                    //grid[x][y].vissible = vissible;
                    cell.className = 'cell';
                    if (!vissible) {
                        cell.dataset.hidden = true;
                        cell.className = 'hidden';
                    }
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => toggleCell(x, y));
                    gridContainer.appendChild(cell);
                }
            }
            drawGrid();
        }

        function getSelectedColor() {
            return document.querySelector('input[name="color"]:checked').value;
        }

        function getSelectedTool() {
            return document.querySelector('input[name="tool"]:checked').value;
        }

        const GLIDER_E = [[0, 1], [0, 2], [1, 0], [1, 2], [2, 2]];

        function rotate(angle, pattern) {
            switch (angle) {
                case 90:
                    return pattern.map(([y, x]) => [x, 2 - y]);
                case 180:
                    return pattern.map(([y, x]) => [2 - y, 2 - x]);
                case 270:
                    return pattern.map(([y, x]) => [2 - x, y]);
                default:
                    return pattern;
            }
        }

        const gliderPatterns = {
            'glider-e': rotate(0, GLIDER_E),
            'glider-s': rotate(90, GLIDER_E),
            'glider-w': rotate(180, GLIDER_E),
            'glider-n': rotate(270, GLIDER_E)
        };

        const toolPatterns = {
            '2x2': [[0, 0], [0, 1], [1, 0], [1, 1]],
            '1x3': [[0, 0], [0, 1], [0, 2]],
            'block': [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]],
            'cross': [[1, 0], [0, 1], [1, 1], [2, 1], [1, 2]],
            'line': [[0, 0], [1, 1], [2, 2]]
        };

        function toggleCell(x, y, overrideColor = null, overrideTool = null) {
            const color = overrideColor || getSelectedColor();
            const tool = overrideTool || getSelectedTool();

            const applyState = (nx, ny) => {
                if (ny < height && nx < width) {
                    if (color === 'random') {
                        const options = ['rock', 'paper', 'scissors'];
                        grid[ny][nx] = options[Math.floor(Math.random() * options.length)];
                    } else {
                        grid[ny][nx] = color === '0' ? 0 : color;
                    }
                }
            };

            if (tool === '1x1') {
                applyState(x, y);
            } else if (tool.startsWith('glider')) {
                let pattern;
                if (tool === 'glider-random') {
                    const keys = Object.keys(gliderPatterns);
                    pattern = gliderPatterns[keys[Math.floor(Math.random() * keys.length)]];
                } else {
                    pattern = gliderPatterns[tool];
                }
                for (const [dy, dx] of pattern) {
                    applyState(x + dx, y + dy);
                }
            } else if (toolPatterns[tool]) {
                for (const [dy, dx] of toolPatterns[tool]) {
                    applyState(x + dx, y + dy);
                }
            }

            drawGrid();
        }

        function cpuAddGlider() {
            const x = Math.floor(Math.random() * (width - 3));
            const y = Math.floor(Math.random() * (height - 3));
            const colorOptions = ['rock', 'paper', 'scissors'];
            const color = colorOptions[Math.floor(Math.random() * colorOptions.length)];
            toggleCell(x, y, color, 'glider-random');
        }

        function drawGrid() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = getCell(x, y);
                    if (cell.dataset.hidden) {
                        continue;
                    }
                    cell.className = 'cell';
                    if (grid[y][x]) cell.classList.add(grid[y][x]);
                }
            }
        }

        function getCell(x, y) {
            if (x < 0 || y < 0 || x >= width || y >= height) return null;
            return gridContainer.children[y * width + x];
        }

        function isCellVisible(x, y) {
            const cell = getCell(x, y);
            return cell && !cell.dataset.hidden;
        }

        function getNeighbors(x, y) {
            const deltas = [-1, 0, 1];
            const neighbors = [];
            for (let dx of deltas) {
                for (let dy of deltas) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx, ny = y + dy;
                    if (isCellVisible(nx, ny)) {
                        neighbors.push(grid[ny][nx]);
                    }
                }
            }
            return neighbors;
        }

        function rpsWinner(a, b) {
            if (a === b) return null;
            const beats = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
            return beats[a] === b ? a : b;
        }

        function step() {
            const newGrid = grid.map(arr => [...arr]);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!isCellVisible(x, y)) continue;
                    const state = grid[y][x];
                    const neighbors = getNeighbors(x, y).filter(n => n);
                    const counts = { rock: 0, paper: 0, scissors: 0 };
                    for (const n of neighbors) counts[n]++;
                    const entries = Object.entries(counts).filter(([k, v]) => v > 0).sort((a, b) => b[1] - a[1]);
                    if (entries.length >= 2 && entries[0][1] !== entries[1][1]) {
                        const winner = rpsWinner(entries[0][0], entries[1][0]);
                        const loser = winner === entries[0][0] ? entries[1][0] : entries[0][0];
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const nx = x + dx, ny = y + dy;
                                if (nx >= 0 && ny >= 0 && nx < width && ny < height && grid[ny][nx] === loser) {
                                    newGrid[ny][nx] = winner;
                                }
                            }
                        }
                    }
                }
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!isCellVisible(x, y)) continue;
                    const state = newGrid[y][x];
                    const neighbors = getNeighbors(x, y);
                    const alive = neighbors.filter(n => n !== 0).length;
                    if (state && (alive < 2 || alive > 3)) newGrid[y][x] = 0;
                    else if (!state && alive === 3) {
                        const types = { rock: 0, paper: 0, scissors: 0 };
                        for (const n of neighbors) if (n) types[n]++;
                        const entries = Object.entries(types).filter(([_, v]) => v > 0).sort((a, b) => b[1] - a[1]);
                        newGrid[y][x] = entries.length > 1 && entries[0][1] === entries[1][1] ? entries[Math.floor(Math.random() * 2)][0] : entries[0][0];
                    }
                }
            }

            grid = newGrid;
            drawGrid();
        }

        document.getElementById('toggleBtn').onclick = () => {
            running = !running;
            document.getElementById('toggleBtn').textContent = running ? 'Stop' : 'Start';
            clearInterval(interval);
            clearInterval(cpuIntervalID);
            if (running) {
                const speed = +document.getElementById('speed').value;
                const cpuDelay = +document.getElementById('cpuInterval').value;
                interval = setInterval(step, speed);
                cpuIntervalID = setInterval(cpuAddGlider, cpuDelay);
            }
        };

        document.getElementById('resetBtn').onclick = () => {
            createGrid();
        };

        document.getElementById('randomizeBtn').onclick = () => {
            const options = ['rock', 'paper', 'scissors', 0];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!isCellVisible(x, y)) continue;
                    grid[y][x] = options[Math.floor(Math.random() * options.length)];
                }
            }
            drawGrid();
        };

        createGrid();
        document.getElementById('toggleBtn').click();
    </script>
</body>

</html>